-- < 정규화 >
-- 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법
-- 데이터 분해 과정
-- 데이터 중복 제거, 뎅이터 모델링의 독립성 확보
-- 1~5 정규화 존재 / 실질적으로 3정규화까지만 수행
-- 정규화를 수행하지 않으면 이상현상 발생

-- < 정규화 절차 >
-- 제 1정규화 : 속성의 원자성 확보 / 기본키 설정
-- 제 2정규화 : 기본키가 2개 이상의 속성으로 이루어진 경우 [ 부분 함수 종속성 ] 제거 분해(테이블 분해)
-- 제 3정규화 : 기본키를 제외한 컬럼 간의 종속성 제거 / [ 이행 함수 종속성 ]제거
-- BCNF : 기본키를 제외하고 후보키가 있는 경우, 후보키가 기본키를 종속시키면 분해
-- 제 4정규화 : 여러 컬럼이 하나의 컬럼을 종속시키는 경우 분해 / [ 다중값 ] 종속성 제거
-- 제 5정규화 : 조인에 의해 종속성이 발생하는 경우 분해
-- 도,부,이,결,다,조 라고 외우자

-- < 함수적 종속성 >
-- 제 1정규화 : 함수적 종속성을 근거로 한다.기본키를 잡는 것
-- 제 2정규화 : 부분함수 종속성 : 기본키가 2개이상의 컬럼으로 이루어진 경우 / 기본키가 1개면 건너뛴다.
-- 제 3정규화 : 이행함수 종속성 : 기본키를 제외하고 컬럼간에 종속성 발생
-- BCNF : 복수의 후보키가 있고, 후보키들이 복합송성이며, 서로 중첩되어야 함

-- < 정규화 문제점 >
-- 테이블 분해로 데이터 중복 제거 => 데이터 모델의 유연성 향상
-- SELECT시 JOIN유발로 인해 CPU와 메모리사용량 증가

-- < 정규화를 사용한 성능 튜닝 >
-- JOIN으로 성능이 저하된 문제를 반정규화로 해결
-- 반정규화 : 데이터 중복을 허용 => 또 다른 문제점 발생
-- 테이블을 나누지 않으면 SELECT 속도 증가
-- 하지만 컬럼이 많아지면 입출력단위인 블록크기를 넘어섬
-- 정규화는 입출력데이터의 양을 줄여서 성능 향상

-- < 반정규화 >
-- DB성능을 향상시키기 위해 데이터 중복 허용, 조인을 줄임
-- SELECT속도는 향상하지만 데이터모델 유연성은 저하

-- < 반정규화를 수행하는 경우 >
-- 정규화에 충실하면 종속성, 활용성은 향샹되지만 / 수행속도가 느려지는 경우
-- 다량의 범위를 자주 처리해야하는 경우
-- 특정 범위의 테이터만 자주 처리하는 경우
-- 요약/집계 정보가 자주 요구되는 경우

-- < 반정규화 절차 >
-- 대상 조사 및 검토 : 데이터 처리범위, 통계성 등 확인해서 대상 조사
-- 다른 방법 검토 : 반정규화 수행 전 다른 방법있는지 확인
-- 반정규화 수행 : 테이블,속성,관계 등 반정규화

-- < 반정규화 기법 >
-- 1. 계산된 컬럼 추가
--		배치 프로그램에서 결과를 미리 계산하고, 특정 컬럼에 추가
-- 2. 테이블 수직 분할
--		하나의 테이블을 두 개 이상의 테이블로 분할
-- 3. 테이블 수평 분할
--		하나의 테이블에 있는 값을 기준으로 테이블 분할
-- 4. 테이블 병함
--		1대1관계 테이블을 병합해서 1대N관계 테이블로 병합 / 슈퍼타입, 서브타입 발생 시 병합해서 성능 향상

-- < 슈퍼타입 , 서브타입 변환 >
-- OneToOne TYPE : 슈퍼타입과 서브타입을 개별 테이블로 도출 / 테이블 수가 많아서 ㅓ조인이 만히 발생하고 관리가 어려움
-- Plus TYPE : 슈퍼타입과 서브타입 테이블로 도출 / 조인이 발생하고 관리가 어렵다
-- Single TYPE : 슈퍼타입과 서브타입을 하나의 테이블로 도촐 / 조인 성능 좋고 관리 편하지만 io성능이 나쁘다