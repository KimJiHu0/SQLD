--ROWNUM SUBQUERY로 사용하기
SELECT * FROM
(SELECT EMPNO, ENAME, SAL , ROWNUM A FROM EMP);

--ROWID
SELECT ROWID, EMPNO FROM EMP;

--WITH 임시테이블
WITH W_EMP AS
(SELECT * FROM DEPT WHERE DEPTNO = 30)
SELECT * FROM W_EMP;

-- EQUI JOIN
SELECT * FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO;

-- INNERJOIN
SELECT * FROM EMP INNER JOIN DEPT
ON EMP.DEPTNO = DEPT.DEPTNO
AND SAL > 2500;

-- INTERSECT : 두 테이블의 공통점 찾기 [ 두 테이블의 공통된 COLUMN은 DEPTNO이다.이를 조회한다. ] <INTERSECT> 
SELECT DEPTNO FROM EMP
INTERSECT
SELECT DEPTNO FROM DEPT;

-- 등가조인(EQUI)은 "=" 을 이용해서 같은 것(교집합)을 조회하고 / 비등가조인(Non-EQUI)은 <, >, >=, <=를 이용해서 정확하지 않은 조인해준다.

-- OUTER JOIN
SELECT * FROM DEPT, EMP
WHERE DEPT.DEPTNO (+)= EMP.DEPTNO ;

--LEFT OUTER JOIN : DEPT테이블과 EMP테이블의 공통된 것으 ㄹ조회하면서 왼쪽테이블에 있는 것만 조회한ㄷ.
SELECT * FROM DEPT LEFT OUTER JOIN EMP
ON DEPT.DEPTNO = EMP.DEPTNO;

SELECT * FROM EMP;
SELECT * FROM DEPT;

-- RIGHT OUTER JOIN
SELECT * FROM DEPT RIGHT OUTER JOIN EMP
ON EMP.DEPTNO = DEPT.DEPTNO;

-- CROSS JOIN : WHERE OR ON 없이 두개의 테이블이 JOIN이 가능하지만 이럴 때 "카테시안 곱"이 발생해서 EMP테이블에서 12개의 행 + DEPT테이블에서 4개의행이 곱해져서 48행이 나온다.
SELECT * FROM EMP CROSS JOIN DEPT;

-- UNION : 합집합이다. 중복데이터를 제거하고 SORT하게 출력.
-- 			UNION을 해주려면 2개의 테이블의 행 갯수가 같고, TYPE이 같아야한다.
SELECT * FROM EMP
UNION
SELECT * FROM EMP;

-- UNION ALL : 중복데이터 제거X , 정렬X : 중복이 제거되지 않아서 24개의 행이 출력.
SELECT * FROM EMP
UNION ALL
SELECT * FROM EMP;

-- MINUS : 처음 SELECT TALBE에는 있고 다음 SELECT TABLE에는 없는 집합을 조회
SELECT DEPTNO FROM DEPT
MINUS
SELECT DEPTNO FROM EMP;
-- DEPT에 DEPTNO는 10,20,30,40이 있고 EMP에는 DEPTNO가 10,20,30이 있다.
-- 처음 SELECT TABLE는 있고, 10,20,30,40
-- 다음 SELECT TABLE에는 없는 10,20,30이 있어서 40이 없네? 그럼 40출력


-- 계층형 조회.
SELECT MAX(LEVEL)
FROM EMP
START WITH MGR IS NULL
CONNECT BY PRIOR  EMPNO = MGR;

-- SUBQUERY
SELECT * FROM EMP --MAIN QUERY
WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE DEPTNO = 10); -- SUBQUERY

-- INLINE VIEW(FROM구에 SELECT문을 쓰기)
SELECT * FROM (SELECT DEPTNO FROM DEPT);

-- IN연산자 : SUBQUERY의 결과가 하나만 참이 되어도 참이 되는 연산
SELECT ENAME, DNAME, SAL FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO
AND EMP.EMPNO IN (SELECT EMPNO FROM EMP WHERE SAL > 2000);

-- ALL연산자 : MAIN QUERY , SUB QUERY 결과가 모두 동일하면 참
-- DEPTNO가 20,30과 같거나 작은애들인 애들의 모든것을 조회.
SELECT * FROM EMP
WHERE DEPTNO <= ALL(20,30);
-- DEPTNO가 20보다 큰 애들을 조회한다.
SELECT * FROM EMP
WHERE DEPTNO > ALL(20);

-- EXISTS : SUBQUERY로 어떤 데이터 존재 여부 확인
-- 얘의 결과는 참, 거짓을 반환
SELECT ENAME, DNAME, SAL
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO
AND EXISTS (SELECT * FROM EMP WHERE SAL > 2000);

-- SCALA SUBQUERY : 반드시 한 행과 한 컬럼이 반환되는 SUBQUERY / 값이 여러개 나올 경우 오류
SELECT ENAME, SAL, (SELECT AVG(SAL) FROM EMP)
FROM EMP;

-- CORRELATED(연관) SUBQUERY : SUBQUERY 내에 MAIN QUERY의 COLUMN을 사용하는 것을 의미
SELECT * FROM EMP E
WHERE E.DEPTNO = (SELECT DEPTNO FROM DEPT D
WHERE E.DEPTNO = D.DEPTNO );

-- ROLLUP : GROUP BY에 대한 COLUMN의 SUBTOTAL을 구한다.
-- 예를 들어 이곳에서는 부서별 평균월급을 구했고
-- GROUP BY ROLLUP(DEPTNO) => GROUPY BY로 묶어준 DEPTNO를 ROLLUP해주겠다는 뜻이라고 볼 수 있다.
SELECT DECODE(DEPTNO, NULL, '전체합계', DEPTNO) AS 부서, SUM(SAL) AS 평균월급 FROM EMP
GROUP BY ROLLUP (DEPTNO);
-- 부서별, 직업별 평균과 전체합계.
SELECT DEPTNO, JOB, SUM(SAL) FROM EMP
GROUP BY ROLLUP(DEPTNO, JOB);

--GROUPING SETS
SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP 
GROUP BY GROUPING SETS(JOB, DEPTNO)

-- CUBE : ROLLUP 중 경우의 수 모두를 출력 [ EX ] = 부서와 직업별 총합이면, 부서별 총합, 직업별총합, 부서 직업의 총합, 전체합계 조회
SELECT DEPTNO, JOB, SUM(SAL) FROM EMP
GROUP BY CUBE(DEPTNO, JOB)

-- RANK : 동일한 순위는 동일한 값 부여 [EX] SAL이 1000이 2명이면 둘다 1, 1 부여
SELECT ENAME, SAL, RANK() OVER(ORDER BY SAL DESC) AS 급여순위, -- 급여순위를 RANK함수를 사용해서 출력. SAL을 DESC해주고, RANK를 부여.(동일한 값은 동일순위로.)
RANK() OVER(PARTITION BY JOB ORDER BY SAL DESC) AS 직업별순위 -- JOB으로 PARTITION을 만들고 JOB별 순위 조회
FROM EMP; 
-- DENSE_RANK : 동일한 순위를 하나의 건수로 부여 [EX] SAL이 1000이 2명이면 1 하나만 부여
SELECT ENAME, SAL,
RANK() OVER(ORDER BY SAL DESC) AS ALL_RANK, -- 동일순위 => 동일값
DENSE_RANK() OVER(ORDER BY SAL DESC) AS DENSERANK -- 동일순위 => 하나의 건수
FROM EMP;
-- ROW_NUMBER : 동일한 순위에 대해서 고유의 값을 부여
SELECT ENAME, SAL,
RANK() OVER(ORDER BY SAL DESC) AS ALL_RANK,
ROW_NUMBER() OVER(ORDER BY SAL DESC) AS ROW_NUM -- 고우의 값을 부여.
FROM EMP;


SELECT ENAME, SAL, SUM(SAL) OVER(PARTITION BY MGR) SUM_MGR
FROM EMP;

-- 행 순서 관련 함수
-- FRIST_VALUE
SELECT DEPTNO, ENAME, SAL ,FIRST_VALUE(ENAME) OVER(PARTITION BY ORDER BY SAL DESC ROWS UNBOUNDED PRECEDING) AS DEPT_A FROM EMP; 
SELECT ENAME, SAL, FIRST_VALUE(ENAME) OVER(ORDER BY SAL ASC) FROM EMP; -- MIN을 가져오는 것과 같은 의미 (행의 가장 첫번쨰 가져옴)
-- LAST_VALUE
SELECT ENAME, SAL, LAST_VALUE(ENAME) OVER(ORDER BY SAL DESC) FROM EMP; -- MAX를 가져오는 것과 같은 의미 (행의 가장 마지막을 가져옴)
-- LAG
SELECT ENAME, SAL, LAG(SAL) OVER(ORDER BY SAL DESC) FROM EMP; -- 이전 값을 가져온다.LAG()안의 값을. => SAL
-- LEAD
SELECT ENAME, SAL, LEAD(1) OVER(ORDER BY SAL DESC) FROM EMP; 


-- PERCENT_RANK() : 파티션을 JOB으로 만들고 그 별로 월급등수를 %로 구한다.
SELECT ENAME, SAL, PERCENT_RANK() OVER(PARTITION BY JOB ORDER BY SAL DESC) FROM EMP; 
-- NTILE() : ()안에 값을 넣어주는데 그에 맞는 등분을 나눠준다.
SELECT DEPTNO, SAL, NTILE(8) OVER(PARTITION BY DEPTNO ORDER BY SAL DESC) FROM EMP;



